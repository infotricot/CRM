В MVC5 включена система аутентификации, которая называется OWIN. 
Требования к паролю можно поменять в папвке App_Start в файле IdentityConfig.cs в следующем коде:

  manager.PasswordValidator = new PasswordValidator
            {
                RequiredLength = 6,
                RequireNonLetterOrDigit = false,
                RequireDigit = false,
                RequireLowercase = false,
                RequireUppercase = false,
            };

		По умолчанию в система аутентификации уже работают следующие функции:
		- Возможность регистрации
		- Осуществление входа
		- Осуществление выхода

О каждом пользователе изначально мы знаем только его e-mail, который одновременно является и логином.
Каждый зарегистрированный пользователь является объектом класса ApplicationUser. 
Если необходимо знать дополнительную информацию о пользователе (например, его имя, фамилию и т.д.)
нужно дописать в этот класс необъодимые свойства.

Класс ApplicationUser находится в папке Models в файле IdentityModels.cs.
Также в этом файле находится ещё один важнейший класс - класс контекста. 

ApplicationDbContext - через этот класс происходит работа с таблицами базы данных.
Работа с таблицами необходимыми для системы аутентификации реализуется в классе IdentityDbContext (к нему доступа),
от которого наследуется наш контекст - класс ApplicationDbContext.
В этом классе можно заметить фразу "DefaultConnection" - это имя строски соединения, с помощью 
которой программа связывается с базой данных. 
Сама строка соединения находится в файле web.config:

<add name="DefaultConnection" connectionString="Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=&quot;|DataDirectory|\aspnet-diplom 2-20171027022007.mdf&quot;;Initial Catalog=&quot;aspnet-diplom 2-20171027022007&quot;;Integrated Security=True" providerName="System.Data.SqlClient" />

Если отркыть содержимое базы данных, указанной с помощью этой строки соединения, то можно увидеть, что 
система аутентификации построена с помощью 5 таблиц. 

Для разработчика актуальны 3 таблицы:
AspNetRoles - содержит список ролей, в которых могут находится зарегистрированные пользователи.
Если нужно добавить новые роли, то это можно сделать прямо в этой таблице. 
Это таблица состоит из двух столбцов - Id роли и название. ВНИМАНИЕ - столец Id имеет тип string.

Таблица AspNetUsers - хранит о зарегистрированных пользователях. 

Таблица AspNetUserRoles - таблица хранит информацию о связях пользователей и ролей. 

--------------------------------------

Веб-приложение состоит из двух частей: 
- клиентская часть (HTML + javascript)
- серверная часть (C#)

Взаимодейтсиве между клиентов и сервером организуется с помощью протокола HTTP.
Протокол - это набор правил (команд, "фраз") по которым могут взаимодействовать (общаться) между собой
два или более устройства. 

HTTP - hypertext transport protocol (hypertext - это язык HTML (CSS))

Работает протокол HTTP по следующему принципу:
1. Клиент (браузер) делает запрос веб-серверу.
Запросы бывают двух видов:
	Get - выполняется когда пользователь вводит некоторый адрес в адресной строке браузера или нажимает по ссылке на странице.
	Post - выполняется когда пользователь нажимает по кнопке, в результате чего происходит отправка каких-либо данных на сервер.

	Когда клиент делает get-запрос, происходит следующий диалог с сервером:
	- Сервер, "дай" мне HTML код, который находится по указанному мной адресу
	- Клиент, получи требуемый тобой HTML-код

	Когда клиент делает post-запрос, происходит следующий диалог с сервером:
	- Сервер, прими следующие данные, которые я отправил тебе по указанному мной адресу
	- Клиент, я получил данные и в результате их обработке я либо верну тебе HTML-код либо перенаправлю
	на другую страницу (адресу). 

	В MVC-приложениях, код выполняемый клиентом находится в папке Views, а код выполняемый сервером
	находится в папке Controllers (Modles).

	Каждый раз, когда пользователь делает get-запрос веб-серверу с MVC-сайтом, он должен 
	указать в этом запросе URL-адрес, в котором должны быть:
	1. Домен (адрес сайта в интернете)
	2. Имя контроллера
	3. Имя Action-метода

	www.mysite.com/Account/Login
	Здесь - www.mysite.com - домен
	Account - имя контроллера
	Login - имя Action-метода

	http://localhost:52654/Home/About

	Каждый Action-метод в результате свой работы должен вернуть пользователю
	html-код запрашиваемой страницы. 
	В MVC говорят, что каждый Action-метод возвращает HTML-код представления (View) с таким же
	именем. 

	Если в url-адресе не указано имени Action-метода, то предполагается, что сервер будет
	обработывать Action-метод с именем index. 
	Например, переход (get-запрос) по адресу:
	http://localhost:52654/Home
	приведёт к выполнению следующего адреса:
	http://localhost:52654/Home/index

	
	Если в url-адресе не указано не имени контроллера, не имени Action-метода, то предполагается, что сервер будет
	обработывать Action-метод с именем index в контроллере Home. 
	
	Например, переход (get-запрос) по адресу:
	http://localhost:52654
	приведёт к выполнению следующего адреса:
	http://localhost:52654/Home/index

	Допустим нам нужна новая страница сайта, на которую можно попасть по следующему адресу:
	http://localhost:52654/Manager/ListOfClients
	Чтобы это сделать, нужно:
	1. Добавить новый контроллер ManagerController
	2. Добавить в этот контроллер Action-метод ListOfClients
	3. Добавить в папку Views новую папку Manager и в неё новое представление с исменем ListOfClients

	http://localhost:52654/Director/Reports

	Обычно один контроллер отвечает за какую-либо одну модель (сущность). 
	Например, есть сущность Client, которая описывает каждого клиента в системе
	Значит, должен быть контроллер ClientsController, в котором будут разные
	Action-методы, осуществляющие управление клиентами, например:
	Add, Edit, Delete, List, Details и т.д.

	Применение HTML-шаблона в проект MVC
	1. Нужно скопировать в папку спроектом все папки шаблона (кроме html файлов)
	2. Скопированные папки перетащить в окно Solution Explorer в проекте Visual Studio.
	3. В visual studio 2015 есть ошибка, из-за которой после перетаскивания содержимое папок 
	в окне Solution Explorer остаётся пустым.
	Поэтому нужно содержмое каждой скопированной папки также перетащить в Обозреватель решений.
	4. Открыть код главной страницы шаблона - файл index.html
	5. Скопировать весь код в файл _Layout.cshtml
	6. Определить часть кода, которая не будет меняться на всех страницах сайта и оставить этот код в _Layout.cshtml.
	Изменяемое содержимое вырезать и вставить в файл index.cshtml в папке Home, на место вырезанного кода в _Layout.cshtml
	написать:
	@RenderBody()
	На месте вызова этого метода будет подставлен html-код нужных страниц.
	7. Если сейчас запустить проект, то результат будет неудовлетворительным, так как не применяются
	css-стили, изображения и скрипты.
	8. Стандартный html шаблон имеет указания подклюячемых имён файлов в несовместимом с MVC виде. 
	Для исправления нужно в коде шаблона подключение всех файлов и дописать к их путям ~/,
	что позволит получить эти файлы относительно корневой папки сайта.
	Например, должно быть так:
	  <img src="~/images/photos/loggeduser.png" alt="" />
	  <link href="~/css/style.default.css" rel="stylesheet">
	   <script src="~/js/dashboard.js"></script>
	9. Если доступ к главной странице должен быть ограничен, тогда на весь контроллер Home
	необходимо добавить атрибут
	[Authorize]
	10. Теперь, при попытке попасть на главную страницу - незарегистрированный пользователь
	будет переадресован автоматически на страницу входа:
	/Account/Login
	Но, мы получим ошибку с текстом:
	The following sections have been defined but have not been rendered for the layout page "~/Views/Shared/_Layout.cshtml": "Scripts".

	Чтобы её исправить нужно в представлении, которое выдаёт такую ошибку убрать следующий код:
	@section Scripts {
		@Scripts.Render("~/bundles/jqueryval")
	}

	--------------------------------------------------------------------------------------------------
	Каждый раз, когда возникает необходимость внесения изменений в структуру таблицы базы данных следуют следующем алгоритму:
	1. Внести изменения в классы, которые отвечают за взаимодействие с базой данных, например, новые свойства, которые мы хотим знать о пользователе:
	 public class ApplicationUser : IdentityUser
    {
	//Добавим имя и фамилия о пользователе
        public string Name { get; set; }
        public string Surname { get; set; }
        
        public async Task<ClaimsIdentity> GenerateUserIdentityAsync(UserManager<ApplicationUser> manager)
        {
            // Обратите внимание, что authenticationType должен совпадать с типом, определенным в CookieAuthenticationOptions.AuthenticationType
            var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie);
            // Здесь добавьте утверждения пользователя
            return userIdentity;
        }
    }
	2. Эти два свойства должны превратиться в новые столбцы некоторый таблицы базы данных. 
	Чтобы это произошло нужно выполнить так называемую "миграцию".
	3. Чтобы сделать миграцию, нужно открыть окно Nuget Package Console (консоль диспетчера пакетов).
	Находится в меню "Сервис" - пункт "Диспетчер пакетов nuget" - пункт "консоль диспетчера пакетов"
	4. В открывшемя окне нужно напечатать и выполнить следующие 3 команды:
	- enable-migrations
	- add-migration любое_имя
	- update-database


	------------------------------------------------------------------------------------------
	Создание новых страниц сайта.
	Каждая страница сайта в MVC состоит из представления и action-метода контроллера,
	его обрабатывающего. 

	Для добавления новой страницы нужно выбрать уже существующий или создать новый контроллер.
	Затем добавить в него новый action-метод, типичный вид которого следующий:
	 
		public ActionResult Index()
        {
			
            return View();
        }

Такой action-метод покажет новое представление с названием Index. Например,
если этот метод будет объявлен в контроллере Home, то чтобы выполнить его нужно
в адресной строке браузера написать:
www.mysite.com/Home/Index

Сами по себе представления используются редко, так как на них обычно нужно показывать
какую-либо информацию взятую из базы данных. Поэтому, если представлению нужно передавать
данные их сначало в Action-методе нужно извлечь из базы, получить список обектов и затем передать
представлению.


Для получения списка пользователей не делают прямое обращения к таблице базы данных черех контекст.
(контекст - это специальный класс библиотеки Entity Framework через который происходит работа 
с базой данных. У нас он находится в папке Models в файле IdentityModels.cs и называется ApplicationDbContext).

Работа с пользователями осуществляется только через специальный объект, называемый UserManager. 
Изначально он доступен через:
HttpContext.GetOwinContext().GetUserManager<ApplicationUserManager>()
Чтобы не писать так сложно, его получают один раз в классе AccountController и дальше использует через
свойство UserManager.

Через этот объект совершаются все действия с пользователями. 
Например, чтобы получить список всех пользователея нужно обратиться к свойству этого объекта Users:
UserManager.Users

Обычно, чтобы такими данными было легче пользоваться их превращают в списки:
UserManager.Users.ToList()

Чтобы передать представлению какие-либо данные нужно указать их в скобках по отношению к методу 
View(), который возвращает представление из Action-метода. Например, чтобы
передать представлению список пользователей, Action-метод будет выглядеть так:

		public ActionResult UsersList()
        {
           return View(UserManager.Users.ToList());
        }

После объявление Action-метода нужно добавить соответствующее ему представление (если оно не было
создано ранее). Для этого нужно нажать правой кнопкой мыши по имение Action-метода в коде контроллера
и выбрать пунт "Добавить представление".  
В открывшемся окне заполнить и выбрать нужные значения в полях. 
В результате мы получим новое представление, которое является комбинацией HTML и C#-кода.

На самом деле в представлениях используется не совсем настоящий C#, а его специальная версия,
которая называется render (визуализатор). Это специальная программа, которая позволяет
с помощью вариации языка C# визуализировать или генерировать сервером HTML-код.
В MVC есть разные render-ы. Стандартный рендер называется Razor. 
Можно понять так, что Razor - это специальная версия языка, позволяющая с помощью C# генерировать
HTML-код. 

Если Action-метод контроллера передал представлению какие-либо данные, то представление должно
быть подготовлено к тому, чтобы их принять.

Данные, которые передаются представлению называются "Моделью представления". 
Чтобы представление смогли такую модель (данные, которые это представление должно получить) принять,
её нужно объявить. ""
Делается это в первой строке представления по следующему принципу:
@model тип_данных

На место тип_данных пишем тот тип, данные которого были переданы из Action-метода контроллера.
List<Product> 

То есть, например, если представление должно получить список товаров, то объявление модели в нём
будет выглядеть так:
@model List<Product>

Если список пользователей:
@model List<ApplicationUser>

Если только одного пользователя:
@model ApplicationUser

Если только один товар:
@model Product

То есть, такими строчками объявляется модель представление (или тип данных, которые оно может получить).

Дальше к этим данным мы обращаемся в представлении с помощью единственного идентификатора Model (!!!!! С БОЛЬШОЙ БУКВЫ)



    //Список<Покупка> Покупки = new Список<Покупок>()
    //for (int i = 0; i < Покупки.Count; i++)
    //{
    //    Покупки[i]
    //}

    //List<ApplicationUser> Users = new List<ApplicationUser>();
    //for (int i = 0; i < Users.Count; i++)
    //{
    //    Console.WriteLine(Users[i].Email +", " + Users[i].Name);
    //}



	Все сайт работают по протоколу HTTP (Hyper text transport protocol)
	Hyper Text - это полное название языка HTML
	HTML - Hyper text marup language (Язык разметки гипертекста)

	Протокол - это набор правил, придерживаясь которых несколько программ или устройств могут между собой взаимодействовать (общаться)

	Протокол базируется на основе принципа отправки запросов и получения ответов. 
	В протоколе HTTP клиент (браузер) может посылать запросы серверу (web-сервер)
	Браузер может отправлять два вида запросов: get и post
	Сервер обрабатывая эти запросы может возвращать ответ в виде HTML-кода, ошибки, или других данных.

	Get-запрос может быть отправлен трёмя способами:
	1. Пользователь браузера вводит адрес в адресной строке в виде URL-адреса. 
	2. Пользователь нажимает по гиперссылке на веб-странице
	3. С посощью ajax-запросов

	В результате get-запросов сервер обычно возвращает HTML-код запрашиваемой страницы, который браузер обрабатывает и отображает пользователю.

	Post-запрос может быть отправлен двумя способами:
	1. С помощью нажатия по кнопке с типом submit, которая находится в теге <form>. В теге form должно быть указана
	куда будут отправлены данные из всех других input-ов имеющихся в этой же форме. 
	2.  С посощью ajax-запросов

	Информация из тегов Input формы будет принята на сервере в указанный в теге <form> action-метод некоторого контроллера (например, ~/Account/Register) 
	и попадёт в параметр (например, model), который является объектом некоторого класса  (например, RegisterViewModel).

	Класс должен состоять из набора свойств, имена которых должно совпадать со значениями атрибутов id и name тегов <input>/
	Например,
	<input id="Email" name="Email" type="text" class="form-control" />
	Значение, которое пользователь напечает в это поле для ввода попадёт в свойство Email объекта model класса RegisterViewModel.

	По умолчанию все Action-метода считаются обработчиками GET-запросов.
	Если Action-метод должен обратывать POST-запрос, то над ним необходимо написать атрибут [HttpPost]

	Несмотря на то, что POST-запросы предназначены для передачи информации на сервер от клиента,
	Get-запросы также имеют некоторые механизмы, для передачи некоторых изменяемых параметров серверу. 

	Основным способм для отправки набольших данных на сервер с помощью GET-запросов являются URL-параметры. 
	Любой запрос требует указания URL-адреса. Поэтому если специальным образом изменгить URL-адрес, то в него можно
	прописать нужные параметры, которые будут переданы серверу. 

	Например,
	http://localhost:52654/Account/Edit
	и нужно отправить на сервер id изменяемого пользователя. Тогда адрес должен выглядеть так:
	http://localhost:52654/Account/Edit?id=3
	Или
	http://google.com.ua?search=купить&lang=en&country=us

	Action-метод обрабатывающий такой запрос должен иметь соответсвующие параметры с такими же именами в своём объявлении.
	В эти параметры попадут значения указанние в url-параметрах.

	Url-адреса с такими параметрами можно гененировать в представлениях следующим образом:
	<a href="~/account/edit?id=@Model[i].Id">Изменить</a>

	Такие url-параметры ещё называют URL-атрибутами.
	--------------------------------------------------------------------
	Поиск пользоватял по его id:
	 ApplicationUser user = UserManager.FindById(id);
	 ----------------------------------

	 Бывают случаи, когда Action-метод возвращает клиенту только html код запрашиваемого представления. Тогда, 
	 он возвращает результат следующим образом:
	    public ActionResult Register()
        {          
            return View();
        }

В дугих случаях в вовзращаемое представления передаются дополнительные данные (информация), которые представления должно
будет отображать или использвать как-то иначе.
Тогда делается это так:

        public ActionResult Edit(string id)
        {
			//находим пользователя
            ApplicationUser user = UserManager.FindById(id);
			//возвращаем представление и передаём ему найденного пользователя
            return View(user);
        }

Если представлению Action-метод передаёт какие-либо данные, то в коде представления должно быть указано - 
какого типа будут эти данные:
@model diplom_2.Models.RegisterViewModel

Такая передача данных от контроллера представлению называется передачей модели.
Модель может быть передано только одна. 
-------------------------------------------------------------------------------------------

Когда необходимо изменить какой-либо объект, например пользователя, на всех этапах нужно знать id этого объекта. 
Таким образом на этапе отправки post-запроса от представления Edit тоже нужно знать и отправить id изменяемого объекта.
Поэтому такое представление обязательно будет содержать дополнительный тег input следующего вида:

<input type="hidden" id="Id" name="Id" value="@Model.Id" />
--------------------------------------------------------------------------
Если необходимо изменить роль пользователя, при этом предполагается, что в системе у одного пользователя может быть только одна роль,
нужно поступать по следующему алгоритму:
0. Возможно, есть смысл проверить - а изменилась ли роль пользователя, и если да, тогда...
1. Удалить пользователя из старой роли
2. Добавить в новую роль.

https://htmlacademy.ru/ 28 уроков пройти

------------------------------------------------------------------------------------------
Entity Framework - библиотека для работы с БД с помощью объектов.
Принцип работы в следующем:
Каждая таблица базы данных соответствует некоторому классу. 
Каждый столбец таблицы соответствует свойству класса. 

Сценарии работы:
1. Code first - программист сначала класс, который в последствии станет таблицей базы данных.
2. Data first - программист сначала создаёт таблицу базы данных, на основе которой получает код класса.
3. Model first - программист в визуальном конструкторе описывает структуру базы данных
и автоматически получает и таблицы и код классов. 

С точки зрения кода работа с библиотекой основана на следующих классах. 

Классы модели. 
Под "моделью" имеется ввиду классы, сопоставляющие таблицы базы данных с аналогичным именем. 
В некоторых случаях имя класса модели указано в единственном числе, тогда как имя таблицы -
во множественном числе. 

Для доступа к таблицам базы данных используется класс, который называют "Контекстом".

Именно этот класс реализует подключение к базе данных и обеспечивает доступ к таблицам. 
Доступ к таблицам в классе-контексте обепсечивается через коллекции типа DbSet.

        public virtual DbSet<field_revision_field_catalog> field_revision_field_catalog { get; set; }
        public virtual DbSet<node> node { get; set; }
        public virtual DbSet<taxonomy_term_data> taxonomy_term_data { get; set; }

Каждая такая коллекция предоствляет доступ к своей таблице базы данных.
DbSet - можно прочитать как набор данных.

Под словом "коллекция" мы понимает все наборы данных такие как "массивы", "списки", "словори" (dictionary) и т.д.
То есть, коллекция - это набор данных, которые можно преобразовть в стандартный список (ToList()),
индексацию (обращение к элементам через порядковый номер в [4], например arr[4]), перебрать элементы циклом,
совершать стандартные операции (добавить элемент, удалить элемент и т.д.)

DbSet - это коллекция, обращаясь к которой мы получим доступ к некоторый таблице базы данных.
Имя объекта такой коллекции совпадает с именем таблицы БД.

В объявление коллекци DbSet в треугольных скобках указывают класс (тип данных), объекты
которого будут храниться в коллекции. В нашем случае - это классы моделей (которые описывают структуру таблицы).
Имя коллекции DbSet должно совпадать с именем таблицы, к которой мы получим доступ через эту коллекции.

Чтобы извлечь данные из таблиц, доступ к которым мы теперь получаем через класс контекста сначало
нужно создать объект класс-контекста:
//Создаём объект класса контекста
meotis_newtricEntities db = new meotis_newtricEntities();
//Получаем данные из таблицы node, преобразуем их в стандартный список с помощью ToList()
//и сохраняем в переменную products.
var products = db.node.ToList();

--------------------------------------------------------------------------------

Классы могут содержать:
- поля (переменные, объявленные в классе). Описывают, информацию и характеристики объектов класса
(например, цвет, скорость, размер)
- методы (функции, объявленные в классе). Описывают действия, которые совершать объект.
- свойства (предоставляют контролируемый доступ к полям класса).
Если доступ свободный, то используют автоматические свойства:
public string Name {get;set;}

public class Client
{
	public string Name; //поле
	public sting Address { get;set; } //автоматическое свойство
	public void Print() //метод
	{
		Console.WriteLine(Name);
	}
}

Если нужно воспользоваться методом Print класса Client сначало нужно создать объект этого класса,
для которого будет выполняться действия.
Client VIP = new Clinet();
VIP.Print();

Методы в классе могут быть статическими:
public class Client
{
	public string Name; //поле
	public sting Address { get;set; } //автоматическое свойство
	public static void PrintAll() //метод
	{
		Console.WriteLine("Information not allowed");
	}
}

Статические методы не принадлежат конкректному объекту, а касаются всего класса Client.
Для статического метода объекта класса не нужен, а вызов осуществляется напрямую через имя класса:
Client.PrintAll();

var - это тип данных который будет определён автоматически, в зависимости от того что присваивается
объекту этого типа

------------------------------------------------------------------------------
Для использования в представлениях кода написанного в других пространствах имён, их необходимо подключать
вначале представления с помощью ключевого слова using:
@using diplom_2.Models

-----------------------------------------------------------------------

Когда контроллер передаёт представлению какие-либо данные, например:
 return View(Products);

 говорят, что Action-метод передаёт представлению некоторую модель. 
 В этом случае под словом "Модель" имеют ввиду данные, которые мы передаём из контроллера в представление.
 То есть, не путать с моделью MVC. 

 Чтобы представление смоглу принять эти данные и работать с ними, в нём должна быть эта модель объявлена.
 Модель с данными представления объявляется в коде представления самой первой строкой и выглядит так:
 @model ТипДанныхКоторыеБылиПереданыПредставления

 Например,
 @model List<Product>

 Часто, после объявления такой строкой можно наблюдать ошибку на тип данных указанный в <>

 Ошибка происходит потому, что класс Product объявлен в пространстве имён моделей (например, diplom_2.Models).
 И из представления это пространство имён (namespace), а следовательно и класс Product недоступны.
 Чтобы они стали доступны нужно подключить пространство имён:
 @using diplom_2.Models

 Для доступа к данными модели в представлении используется спеицальный идентификатор - Model.
 Таким образом, если нужно работать с данными, делаем это так:
 @Model[0].Name - выводим название первого товара. 

 Асинхронные запросы Get и Post. При получении ответа от асинхронного
 запроса браузер не будет перегружать всю страницу. 
 С помощью этого подхода можно обновить только нужную часть страницы, а не всю целиком. 

 Реализуется это с помощью технологии ajax или ajax-запросы на языке javascript. 

 Для отправки и обработки ajax-запроса нужно знать и сделать следующие вещи:
 ----Перед отправкой запроса контейнер, в котором будем размещать новое содержимое
 нужно отчистить или отобразить лоадер.---
 1. На какой URL-адрес отправлять запрос. 
 2. Указать тип запроса (get или post)
 3. Если речь идёт о post-запросе указать передаваемые данные.
 4. Указать тип отправляемого контента по HTML-стандартам. 
 5. Описать функцию, в которой указывается - что делать, если во время запроса произошла ошибка.
 6. Описать функцию, в которой обрабатывается ситуация, когда запрос выполнен успешно.
 Такая функция получает результат работы выполненной сервером (обычно в виде текста на HTML).
 Этот результат подставляется в место страницы, которую нужно обновить. 
  ----Спрятать загрузчик---

  post-запросы клиент на сервер может отправить двумя способами:
  1. По нажатию на кнопку с типом submit, которая находится внутри формы
  2. С помощью ajax-запроса. 

  Форма, отправляющая post-запрос выглядит так:
  <form type="post" action="~/Contacts/Create">
	<input type="text" />
	<input type="button" />
	<input type="submit" />
  </form>

  В проекте MVC в представлениях этих тегов можно не найти, так как вместо них используются
  так называемые хелперы (helpers).

  Хелперы - это С# вместо которых на странице будет сгенерирован тот или иной HTML-код.
  Например, вместо:
   <form type="post" action="~/Contacts/Create">
   в коде представления есть:
     @using (Html.BeginForm())

	 Или, хелпер:
	 @Html.EditorFor(model => model.FIO, new { htmlAttributes = new { @class = "form-control" } })
	 будет заменён в браузере на html-код:	 
	 <input class="form-control text-box single-line" id="FIO" name="FIO" type="text" value="">















